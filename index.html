<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Component Synthesizer</title>
    <style>
        :root {
            --bg-color: #282c34;
            --text-color: #abb2bf;
        }
        html { box-sizing: border-box; }
        *, *:before, *:after { box-sizing: inherit; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 2rem;
        }
    </style>
</head>
<body>

<synth-app></synth-app>

<template id="sequencer-step-template">
    <style>
        :host {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        .pitch-slider {
            -webkit-appearance: slider-vertical;
            appearance: slider-vertical;
            width: 15px;
            height: 80px;
            padding: 0;
            margin: 0;
        }
        .pitch-slider:disabled { opacity: 0.5; }
        .step-button {
            width: 80%;
            height: 25px;
            background-color: var(--led-off, #3a3f4b);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            transition: background-color 0.1s;
        }
        :host([active]) .step-button { background-color: var(--led-on, #c678dd); }
        :host([current]) .step-button::after {
            content: '';
            position: absolute;
            top: -4px; right: -4px; bottom: -4px; left: -4px;
            border: 2px solid var(--led-active, #98c379);
            border-radius: 6px;
        }
        .has-data {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 6px;
            height: 6px;
            background-color: var(--accent-color, #61afef);
            border-radius: 50%;
            display: none;
        }
        :host([has-data]) .has-data { display: block; }

        @media (max-width: 600px) {
            .pitch-slider { height: 60px; }
        }
    </style>
    <input type="range" class="pitch-slider" min="36" max="84" value="60" step="1">
    <div class="step-button">
        <div class="has-data"></div>
    </div>
</template>

<template id="synth-app-template">
    <style>
        :host {
            --control-bg: #444b58;
            --accent-color: #61afef;
            --led-off: #3a3f4b;
            --led-on: #c678dd;
            --led-active: #98c379;

            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            background-color: var(--control-bg);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        h2, h3, h4 { margin: 0; text-align: center; }
        h2 { color: var(--accent-color); border-bottom: 1px solid #555; padding-bottom: 10px; }
        h4 { margin-bottom:10px; margin-top:20px; }
        .control-group { background: #333944; padding: 15px; border-radius: 8px; }
        .control-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 20px; }
        .control { display: flex; flex-direction: column; align-items: center; }
        label { margin-bottom: 8px; font-size: 0.9em; }
        input[type="range"] { width: 100px; }
        button, input[type="file"] {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover { background-color: #529bde; }
        #tuningName { font-size: 0.8em; margin-top: 5px; }

        @media (max-width: 600px) {
            :host { padding: 15px; gap: 15px; }
            .control-grid { gap: 15px; }
            h2 { font-size: 1.5em; }
            h3, h4 { font-size: 1.1em; }
            label { font-size: 0.85em; }
        }
        @media (max-width: 400px) {
            :host { padding: 10px; }
            .control-group { padding: 10px; }
        }
    </style>

    <h2>Web Component Synthesizer</h2>

    <div class="control-group">
        <div class="control-grid" style="grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));">
            <div class="control">
                <button id="startStopBtn">Start</button>
                <span>Tempo: <span id="tempoValue">120</span> BPM</span>
                <input type="range" id="tempo" min="30" max="240" value="120">
            </div>
             <div class="control">
                <label>Save/Load</label>
                <button id="saveSong">Save Song</button>
                <button id="loadSong">Load Song</button>
                <input type="file" id="loadSongInput" accept=".json" style="display:none;">
            </div>
            <div class="control">
                <label>Tuning</label>
                <button id="loadScl">Load .scl</button>
                <input type="file" id="tuningFile" accept=".scl" style="display:none;">
                <span id="tuningName">12-TET</span>
            </div>
        </div>
    </div>

    <div class="control-group">
        <h3>SYNTHESIZER</h3>
        <div class="control-grid">
            <div class="control"><label>Waveform</label><select id="osc-waveform"><option value="sawtooth">Sawtooth</option><option value="square">Square</option><option value="triangle">Triangle</option><option value="sine">Sine</option></select></div>
            <div class="control"><label>Filter Cutoff</label><input type="range" id="filter-cutoff" min="20" max="8000" value="1000" step="1"></div>
            <div class="control"><label>Filter Resonance</label><input type="range" id="filter-resonance" min="0.1" max="18" value="1" step="0.1"></div>
            <div class="control"><label>Pitch LFO Rate</label><input type="range" id="pitch-lfo-rate" min="0.1" max="20" value="5" step="0.1"></div>
            <div class="control"><label>Pitch LFO Depth</label><input type="range" id="pitch-lfo-depth" min="0" max="25" value="0" step="1"></div>
            <div class="control"><label>Cutoff LFO Rate</label><input type="range" id="cutoff-lfo-rate" min="0.1" max="20" value="2" step="0.1"></div>
            <div class="control"><label>Cutoff LFO Depth</label><input type="range" id="cutoff-lfo-depth" min="0" max="4000" value="0" step="10"></div>
        </div>
        <h4>ADSR Envelope</h4>
        <div class="control-grid">
            <div class="control"><label>Attack</label><input type="range" id="env-attack" min="0.01" max="2" value="0.02" step="0.01"></div>
            <div class="control"><label>Decay</label><input type="range" id="env-decay" min="0.01" max="2" value="0.2" step="0.01"></div>
            <div class="control"><label>Sustain</label><input type="range" id="env-sustain" min="0" max="1" value="0.8" step="0.01"></div>
            <div class="control"><label>Release</label><input type="range" id="env-release" min="0.01" max="3" value="0.3" step="0.01"></div>
        </div>
    </div>

    <div class="control-group">
        <h3>EFFECTS</h3>
        <div class="control-grid">
            <div class="control"><label>Reverb</label><input type="range" id="reverb-mix" min="0" max="1" value="0.2" step="0.01"></div>
            <div class="control"><label>Echo Time</label><input type="range" id="delay-time" min="0" max="1" value="0.25" step="0.01"></div>
            <div class="control"><label>Echo Feedback</label><input type="range" id="delay-feedback" min="0" max="0.9" value="0.4" step="0.01"></div>
        </div>
        <div class="control-grid" style="margin-top: 15px;">
            <div class="control"><label>EQ Low</label><input type="range" class="eq-gain" data-freq="250" min="-24" max="24" value="0" step="1"></div>
            <div class="control"><label>EQ Mid</label><input type="range" class="eq-gain" data-freq="1000" min="-24" max="24" value="0" step="1"></div>
            <div class="control"><label>EQ High</label><input type="range" class="eq-gain" data-freq="4000" min="-24" max="24" value="0" step="1"></div>
        </div>
    </div>

    <div class="control-group">
        <h3>SEQUENCER</h3>
        <step-sequencer></step-sequencer>
    </div>
</template>

<script>
// --- Component: A single sequencer step ---
class SequencerStep extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        const template = document.getElementById('sequencer-step-template');
        this.shadowRoot.appendChild(template.content.cloneNode(true));

        this._slider = this.shadowRoot.querySelector('.pitch-slider');
        this._button = this.shadowRoot.querySelector('.step-button');
    }

    connectedCallback() {
        this._button.addEventListener('click', this._onClick.bind(this));
        this._slider.addEventListener('input', this._onSliderInput.bind(this));
    }

    static get observedAttributes() {
        return ['active', 'current', 'has-data', 'note', 'disabled'];
    }

    attributeChangedCallback(name, oldValue, newValue) {
        switch (name) {
            case 'note': this._slider.value = newValue; break;
            case 'disabled': this._slider.disabled = this.hasAttribute('disabled'); break;
        }
    }

    _onClick(e) {
        this.dispatchEvent(new CustomEvent('stepclick', {
            bubbles: true, composed: true,
            detail: {
                shiftKey: e.shiftKey,
                index: parseInt(this.dataset.index, 10)
            }
        }));
    }

    _onSliderInput(e) {
        this.dispatchEvent(new CustomEvent('sliderinput', {
            bubbles: true, composed: true,
            detail: {
                note: parseInt(e.target.value, 10),
                index: parseInt(this.dataset.index, 10)
            }
        }));
    }
}
customElements.define('sequencer-step', SequencerStep);

// --- Component: The main step sequencer grid ---
class StepSequencer extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this.shadowRoot.innerHTML = `
            <style>
                :host { display: block; }
                .grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(45px, 1fr));
                    gap: 8px;
                    align-items: end;
                }
                @media (max-width: 600px) { .grid { gap: 5px; } }
            </style>
            <div class="grid"></div>
        `;
        this._grid = this.shadowRoot.querySelector('.grid');
    }

    connectedCallback() {
        for (let i = 0; i < 16; i++) {
            const step = document.createElement('sequencer-step');
            step.dataset.index = i;
            this._grid.appendChild(step);
        }
    }

    updateStep(index, data) {
        const step = this._grid.children[index];
        if (!step) return;

        Object.keys(data).forEach(key => {
            const value = data[key];
            if (value === true) step.setAttribute(key, '');
            else if (value === false) step.removeAttribute(key);
            else step.setAttribute(key, value);
        });
    }
}
customElements.define('step-sequencer', StepSequencer);

// --- Component: The main synthesizer application ---
class SynthApp extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        const template = document.getElementById('synth-app-template');
        this.shadowRoot.appendChild(template.content.cloneNode(true));

        // App State
        this.audioContext = null;
        this.mainGain = null;
        this.isPlaying = false;
        this.currentStep = 0;
        this.tempo = 120;
        this.nextStepTime = 0.0;
        this.timerID = null;
        this.baseMidiNote = 60;
        this.baseFrequency = 261.626;
        this.scaleRatios = Array.from({ length: 128 }, (_, i) => Math.pow(2, (i - this.baseMidiNote) / 12));
        this.effects = {};
        this.sequencerData = Array(16).fill(null);
        this.sequencerStepParams = Array(16).fill(null);
    }

    connectedCallback() {
        this.sequencer = this.shadowRoot.querySelector('step-sequencer');
        this.renderSequencerState();
        this.addEventListeners();
    }

    addEventListeners() {
        this.shadowRoot.getElementById('startStopBtn').addEventListener('click', () => this.isPlaying ? this.stopSequencer() : this.startSequencer());
        this.shadowRoot.getElementById('tempo').addEventListener('input', e => {
            this.tempo = parseFloat(e.target.value);
            this.shadowRoot.getElementById('tempoValue').textContent = this.tempo;
        });
        this.shadowRoot.getElementById('saveSong').addEventListener('click', () => this.saveSong());
        this.shadowRoot.getElementById('loadSong').addEventListener('click', () => this.shadowRoot.getElementById('loadSongInput').click());
        this.shadowRoot.getElementById('loadSongInput').addEventListener('change', e => this.handleFileLoad(e, this.loadSong.bind(this)));
        this.shadowRoot.getElementById('loadScl').addEventListener('click', () => this.shadowRoot.getElementById('tuningFile').click());
        this.shadowRoot.getElementById('tuningFile').addEventListener('change', e => this.handleFileLoad(e, this.parseScl.bind(this), e.target.files[0].name));

        this.sequencer.addEventListener('stepclick', e => {
            const index = e.detail.index;
            const stepComponent = this.sequencer.shadowRoot.querySelector(`sequencer-step[data-index='${index}']`);

            if (e.detail.shiftKey) {
                this.sequencerStepParams[index] = this.sequencerStepParams[index] ? null : this.getGlobalSynthParams();
            } else {
                this.sequencerData[index] = this.sequencerData[index] === null ? parseInt(stepComponent.getAttribute('note') || 60, 10) : null;
            }
            this.renderSequencerState();
        });

        this.sequencer.addEventListener('sliderinput', e => {
            const index = e.detail.index;
            if (this.sequencerData[index] !== null) {
                this.sequencerData[index] = e.detail.note;
            }
        });

        this.shadowRoot.querySelectorAll('.control-group input, .control-group select').forEach(el => {
            el.addEventListener('input', e => {
                if(!this.audioContext || !this.effects.reverbGain) return;
                switch(e.target.id) {
                    case 'reverb-mix': this.effects.reverbGain.gain.value = parseFloat(e.target.value); break;
                    case 'delay-time': this.effects.delay.delayTime.value = parseFloat(e.target.value); break;
                    case 'delay-feedback': this.effects.feedback.gain.value = parseFloat(e.target.value); break;
                }
                if(e.target.classList.contains('eq-gain')) {
                    const index = Array.from(this.shadowRoot.querySelectorAll('.eq-gain')).indexOf(e.target);
                    if (this.effects.eqBands[index]) this.effects.eqBands[index].gain.value = parseFloat(e.target.value);
                }
            });
        });
    }

    initAudio() {
        if (this.audioContext) return;
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        this.mainGain = this.audioContext.createGain(); this.mainGain.gain.value = 0.7;
        let lastNode = this.mainGain;

        this.effects.eqBands = [];
        ['lowshelf', 'peaking', 'highshelf'].forEach((type, i) => {
            const eq = this.audioContext.createBiquadFilter();
            eq.type = type; eq.frequency.value = [250, 1000, 4000][i];
            lastNode.connect(eq); lastNode = eq; this.effects.eqBands.push(eq);
        });

        this.effects.delay = this.audioContext.createDelay();
        this.effects.feedback = this.audioContext.createGain();
        lastNode.connect(this.effects.delay); this.effects.delay.connect(this.effects.feedback); this.effects.feedback.connect(this.effects.delay);
        lastNode = this.effects.delay;

        this.effects.convolver = this.audioContext.createConvolver();
        this.effects.reverbGain = this.audioContext.createGain();
        lastNode.connect(this.effects.convolver); this.effects.convolver.connect(this.effects.reverbGain);
        this.effects.reverbGain.connect(this.audioContext.destination);
        lastNode.connect(this.audioContext.destination);

        this.shadowRoot.querySelectorAll('input[type=range], select').forEach(el => el.dispatchEvent(new Event('input')));
        this.createReverbImpulseResponse();
    }

    createReverbImpulseResponse() {
        const rate = this.audioContext.sampleRate, length = rate * 2;
        const impulse = this.audioContext.createBuffer(2, length, rate);
        for (let i = 0; i < length; i++) {
            impulse.getChannelData(0)[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.5);
            impulse.getChannelData(1)[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.5);
        }
        this.effects.convolver.buffer = impulse;
    }

    getFrequencyForNote(note) {
        if (note < 0 || note > 127) return 0;
        return this.baseFrequency * this.scaleRatios[note];
    }

    startSequencer() {
        if (this.isPlaying) return;
        if (!this.audioContext) this.initAudio();
        this.isPlaying = true;
        this.currentStep = 0;
        this.nextStepTime = this.audioContext.currentTime;
        this.scheduler();
        this.shadowRoot.getElementById('startStopBtn').textContent = 'Stop';
    }

    stopSequencer() {
        this.isPlaying = false;
        window.clearTimeout(this.timerID);
        this.shadowRoot.getElementById('startStopBtn').textContent = 'Start';
        this.updateSequencerUI(-1);
    }

    scheduler() {
        while (this.nextStepTime < this.audioContext.currentTime + 0.1) {
            this.scheduleStep(this.currentStep, this.nextStepTime);
            this.nextStepTime += (60.0 / this.tempo) / 4;
            this.currentStep = (this.currentStep + 1) % 16;
        }
        this.timerID = window.setTimeout(this.scheduler.bind(this), 25.0);
    }

    scheduleStep(stepIndex, time) {
        const note = this.sequencerData[stepIndex];
        if (note !== null) {
            const params = this.sequencerStepParams[stepIndex] || this.getGlobalSynthParams();
            this.playSequencerNoteAtTime(note, time, params);
        }
        setTimeout(() => this.updateSequencerUI(stepIndex), (time - this.audioContext.currentTime) * 1000);
    }

    playSequencerNoteAtTime(note, time, params) {
        class Voice {
            constructor(note, app) {
                this.note = note;
                this.app = app;
                const ac = app.audioContext;

                this.osc = ac.createOscillator();
                this.filter = ac.createBiquadFilter();
                this.vca = ac.createGain();
                this.pitchLFO = ac.createOscillator();
                this.pitchLFOGain = ac.createGain();
                this.cutoffLFO = ac.createOscillator();
                this.cutoffLFOGain = ac.createGain();

                this.pitchLFO.connect(this.pitchLFOGain); this.pitchLFOGain.connect(this.osc.detune);
                this.cutoffLFO.connect(this.cutoffLFOGain); this.cutoffLFOGain.connect(this.filter.frequency);
                this.osc.connect(this.filter); this.filter.connect(this.vca); this.vca.connect(app.mainGain);

                this.vca.gain.value = 0;
                this.osc.frequency.value = app.getFrequencyForNote(note);
                this.filter.type = 'lowpass';

                this.osc.start(); this.pitchLFO.start(); this.cutoffLFO.start();
            }
            applyParams(params) {
                const ac = this.app.audioContext;
                this.osc.type = params.waveform;
                this.filter.frequency.setTargetAtTime(params.cutoff, ac.currentTime, 0.01);
                this.filter.Q.setTargetAtTime(params.resonance, ac.currentTime, 0.01);
                this.pitchLFO.frequency.setTargetAtTime(params.pitchLfoRate, ac.currentTime, 0.01);
                this.pitchLFOGain.gain.setTargetAtTime(params.pitchLfoDepth, ac.currentTime, 0.01);
                this.cutoffLFO.frequency.setTargetAtTime(params.cutoffLfoRate, ac.currentTime, 0.01);
                this.cutoffLFOGain.gain.setTargetAtTime(params.cutoffLfoDepth, ac.currentTime, 0.01);
            }
            disconnect() {
                this.osc.stop(); this.pitchLFO.stop(); this.cutoffLFO.stop();
                this.osc.disconnect(); this.filter.disconnect(); this.vca.disconnect();
                this.pitchLFO.disconnect(); this.cutoffLFO.disconnect();
            }
        }

        const voice = new Voice(note, this);
        voice.applyParams(params);
        const noteDuration = (60.0 / this.tempo) / 4 * 0.95;
        const noteEndTime = time + noteDuration;
        const { attack, decay, sustain, release } = params.adsr;
        voice.vca.gain.setValueAtTime(0, time);
        voice.vca.gain.linearRampToValueAtTime(1.0, time + attack);
        voice.vca.gain.linearRampToValueAtTime(sustain, time + attack + decay);
        voice.vca.gain.setValueAtTime(sustain, noteEndTime);
        voice.vca.gain.linearRampToValueAtTime(0, noteEndTime + release);
        setTimeout(() => voice.disconnect(), (noteEndTime + release - this.audioContext.currentTime) * 1000 + 50);
    }

    updateSequencerUI(currentPlayingStep) {
        for(let i=0; i<16; i++) {
            this.sequencer.updateStep(i, { current: i === currentPlayingStep });
        }
    }

    renderSequencerState() {
        for(let i=0; i<16; i++) {
            const stepIsActive = this.sequencerData[i] !== null;
            this.sequencer.updateStep(i, {
                active: stepIsActive,
                'has-data': this.sequencerStepParams[i] !== null,
                note: stepIsActive ? this.sequencerData[i] : 60,
                disabled: !stepIsActive
            });
        }
    }

    getGlobalSynthParams() {
        const s = (id) => this.shadowRoot.getElementById(id);
        return {
            waveform: s('osc-waveform').value,
            cutoff: parseFloat(s('filter-cutoff').value), resonance: parseFloat(s('filter-resonance').value),
            pitchLfoRate: parseFloat(s('pitch-lfo-rate').value), pitchLfoDepth: parseFloat(s('pitch-lfo-depth').value),
            cutoffLfoRate: parseFloat(s('cutoff-lfo-rate').value), cutoffLfoDepth: parseFloat(s('cutoff-lfo-depth').value),
            adsr: {
                attack: parseFloat(s('env-attack').value), decay: parseFloat(s('env-decay').value),
                sustain: parseFloat(s('env-sustain').value), release: parseFloat(s('env-release').value),
            }
        };
    }

    applyGlobalSynthParams(params) {
        const s = (id, val) => this.shadowRoot.getElementById(id).value = val;
        s('osc-waveform', params.waveform);
        s('filter-cutoff', params.cutoff); s('filter-resonance', params.resonance);
        s('pitch-lfo-rate', params.pitchLfoRate); s('pitch-lfo-depth', params.pitchLfoDepth);
        s('cutoff-lfo-rate', params.cutoffLfoRate); s('cutoff-lfo-depth', params.cutoffLfoDepth);
        s('env-attack', params.adsr.attack); s('env-decay', params.adsr.decay);
        s('env-sustain', params.adsr.sustain); s('env-release', params.adsr.release);
    }

    saveSong() {
        const songData = {
            tempo: this.tempo, sequencerData: this.sequencerData, sequencerStepParams: this.sequencerStepParams,
            synthParams: this.getGlobalSynthParams(),
            effects: {
                reverb: parseFloat(this.shadowRoot.getElementById('reverb-mix').value),
                delayTime: parseFloat(this.shadowRoot.getElementById('delay-time').value),
                delayFeedback: parseFloat(this.shadowRoot.getElementById('delay-feedback').value),
                eq: Array.from(this.shadowRoot.querySelectorAll('.eq-gain')).map(s => parseFloat(s.value))
            }
        };
        const blob = new Blob([JSON.stringify(songData, null, 2)], { type: 'application/json' });
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
        a.download = 'wc-synth-song.json'; a.click(); URL.revokeObjectURL(a.href);
    }

    loadSong(songData) {
        this.tempo = songData.tempo; this.shadowRoot.getElementById('tempo').value = this.tempo;
        this.shadowRoot.getElementById('tempoValue').textContent = this.tempo;
        this.sequencerData = songData.sequencerData;
        this.sequencerStepParams = songData.sequencerStepParams || Array(16).fill(null);
        this.applyGlobalSynthParams(songData.synthParams);

        this.shadowRoot.getElementById('reverb-mix').value = songData.effects.reverb;
        this.shadowRoot.getElementById('delay-time').value = songData.effects.delayTime;
        this.shadowRoot.getElementById('delay-feedback').value = songData.effects.delayFeedback;
        this.shadowRoot.querySelectorAll('.eq-gain').forEach((s, i) => s.value = songData.effects.eq[i]);

        this.shadowRoot.querySelectorAll('input[type="range"], select').forEach(el => el.dispatchEvent(new Event('input')));
        this.renderSequencerState(); alert('Song loaded successfully!');
    }

    parseScl(sclData, fileName) {
        const lines = sclData.split('\n').map(l => l.trim()).filter(l => !l.startsWith('!') && l);
        const noteCount = parseInt(lines[1], 10); const newRatios = [1];
        for (let i = 2; i < lines.length; i++) {
            let ratio;
            if (lines[i].includes('.')) { ratio = Math.pow(2, parseFloat(lines[i]) / 1200); }
            else if (lines[i].includes('/')) { const [num, den] = lines[i].split('/'); ratio = parseFloat(num) / parseFloat(den); }
            else { ratio = parseInt(lines[i], 10); if (ratio > 0) ratio = Math.pow(2, ratio / 1200);}
            newRatios.push(ratio);
        }
        const period = newRatios.find(r => r >= 2) || 2;
        this.scaleRatios = Array(128).fill(0).map((_, i) => {
            const midiNote = i - this.baseMidiNote; const octave = Math.floor(midiNote / noteCount);
            const noteInScale = midiNote % noteCount;
            return Math.pow(period, octave) * newRatios[noteInScale < 0 ? noteInScale + noteCount : noteInScale];
        });
        this.shadowRoot.getElementById('tuningName').textContent = fileName;
    }

    handleFileLoad(event, callback, fileName = '') {
        const file = event.target.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = fileName.endsWith('.json') || fileName === '' ? JSON.parse(e.target.result) : e.target.result;
                callback(data, fileName);
            }
            catch (err) { alert('Error loading file.'); console.error(err); }
        };
        reader.readAsText(file);
        event.target.value = '';
    }
}
customElements.define('synth-app', SynthApp);
</script>

</body>
</html>
